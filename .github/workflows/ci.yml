name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    name: Tests and Coverage
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_USER: postgres
          POSTGRES_DB: quest_manager_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Install dependencies
      run: go mod download

    - name: Wait for PostgreSQL
      run: |
        until pg_isready -h localhost -p 5432 -U postgres; do
          echo "Waiting for PostgreSQL..."
          sleep 2
        done

    - name: Run Unit Tests
      run: |
        echo "üß™ Running Unit Tests..."
        go test ./tests/domain -v -race -coverprofile=unit_coverage.out

    - name: Run Contract Tests
      run: |
        echo "ü§ù Running Contract Tests..."
        go test ./tests/contracts -v -race

    - name: Run Integration Tests with Coverage
      env:
        DB_HOST: localhost
        DB_PORT: "5432"
        DB_USER: postgres
        DB_PASSWORD: postgres
        DB_NAME: quest_manager_test
        DB_SSLMODE: disable
      run: |
        echo "üîó Running Integration Tests..."
        go test -tags=integration -v -race -p 1 -count=1 -coverprofile=integration_coverage.out -coverpkg=./internal/... ./tests/integration/...

    - name: Generate Coverage Report
      run: |
        echo "üìä Generating Coverage Report..."
        
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –ø–æ–∫—Ä—ã—Ç–∏–µ unit –∏ integration —Ç–µ—Å—Ç–æ–≤
        echo "mode: atomic" > total_coverage.out
        
        # –î–æ–±–∞–≤–ª—è–µ–º unit coverage (–∏—Å–∫–ª—é—á–∞—è –∑–∞–≥–æ–ª–æ–≤–æ–∫)
        if [ -f unit_coverage.out ]; then
          tail -n +2 unit_coverage.out >> total_coverage.out
        fi
        
        # –î–æ–±–∞–≤–ª—è–µ–º integration coverage (–∏—Å–∫–ª—é—á–∞—è –∑–∞–≥–æ–ª–æ–≤–æ–∫)
        if [ -f integration_coverage.out ]; then
          tail -n +2 integration_coverage.out >> total_coverage.out
        fi
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤—ã–π –æ—Ç—á–µ—Ç
        go tool cover -func=total_coverage.out > coverage_summary.txt
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        echo "üìà Coverage Summary:"
        cat coverage_summary.txt
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏—Ç–æ–≥–æ–≤—ã–π –ø—Ä–æ—Ü–µ–Ω—Ç
        COVERAGE=$(go tool cover -func=total_coverage.out | tail -1 | awk '{print $NF}' | sed 's/%//')
        echo "TOTAL_COVERAGE=$COVERAGE" >> $GITHUB_ENV
        echo "Final Coverage: $COVERAGE%"

    - name: Run Coverage Check Script
      run: |
        echo "üéØ Running Coverage Check Script..."
        chmod +x scripts/coverage-check.sh
        ./scripts/coverage-check.sh

    - name: Run Test Statistics
      run: |
        echo "üìä Running Test Statistics..."
        chmod +x scripts/test-stats.sh
        ./scripts/test-stats.sh

    - name: Coverage Report Generated
      run: |
        echo "‚úÖ Coverage report generated successfully!"
        echo "üìä Total coverage file: ./total_coverage.out"
        echo "üéØ All tests completed successfully!"

    - name: Comment Coverage on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const coverage = process.env.TOTAL_COVERAGE;
          const fs = require('fs');
          
          // –ß–∏—Ç–∞–µ–º summary –ø–æ–∫—Ä—ã—Ç–∏—è
          const coverageSummary = fs.readFileSync('coverage_summary.txt', 'utf8');
          
          const body = `## üìä Test Coverage Report
          
          **Total Coverage: ${coverage}%**
          
          ### Coverage by Package:
          \`\`\`
          ${coverageSummary}
          \`\`\`
          
          ### Test Results:
          - ‚úÖ Unit Tests: Passed
          - ‚úÖ Contract Tests: Passed  
          - ‚úÖ Integration Tests: Passed
          
          ### Coverage Goals:
          - üéØ Target: >80% for internal/ code
          - ${coverage >= 80 ? '‚úÖ' : '‚ö†Ô∏è'} Current: ${coverage}%
          
          ---
          *Generated by Quest Manager CI/CD Pipeline*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });

    - name: Check Coverage Threshold
      run: |
        COVERAGE=${{ env.TOTAL_COVERAGE }}
        THRESHOLD=70
        
        echo "Coverage: $COVERAGE%"
        echo "Threshold: $THRESHOLD%"
        
        if (( $(echo "$COVERAGE < $THRESHOLD" | bc -l) )); then
          echo "‚ùå Coverage $COVERAGE% is below threshold $THRESHOLD%"
          exit 1
        else
          echo "‚úÖ Coverage $COVERAGE% meets threshold $THRESHOLD%"
        fi

  lint:
    name: Linting
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v3
      with:
        version: latest
        args: --timeout=5m

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, lint]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'

    - name: Build application
      run: |
        echo "üî® Building Quest Manager..."
        make build
        
    - name: Test binary
      run: |
        ls -la task-server
        ./task-server --help || echo "Binary created successfully"